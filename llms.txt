Project Structure:
📁 fonttools-opentype-hinting-freezer
├── 📁 assets
├── 📁 github-workflows
│   ├── 📄 ci.yml
│   └── 📄 release.yml
├── 📁 opentype_hinting_freezer
│   ├── 📄 __init__.py
│   ├── 📄 __main__.py
│   └── 📄 hintingfreezer.py
├── 📁 opentype_hinting_freezer.egg-info
├── 📁 scripts
│   ├── 📄 build.sh
│   ├── 📄 release.sh
│   └── 📄 test.sh
├── 📁 tests
│   ├── 📁 data
│   ├── 📄 conftest.py
│   ├── 📄 generate_minimal_ttf.py
│   ├── 📄 test_cli_integration.py
│   ├── 📄 test_error_handling.py
│   ├── 📄 test_functionality.py
│   ├── 📄 test_hintingfreezer_unit.py
│   └── 📄 test_performance.py
├── 📄 .gitignore
├── 📄 AUTHORS.txt
├── 📄 CHANGELOG.md
├── 📄 CONTRIBUTORS.txt
├── 📄 GITHUB_WORKFLOWS_SETUP.md
├── 📄 IMPLEMENTATION_SUMMARY.md
├── 📄 LICENSE
├── 📄 mypy.ini
├── 📄 PLAN.md
├── 📄 pyproject.toml
├── 📄 README.md
├── 📄 README_DEVELOPMENT.md
├── 📄 REFACTOR_FILELIST.txt
├── 📄 REFACTOR_SPLITTING.md
├── 📄 setup.py
└── 📄 TODO.md


<documents>
<document index="1">
<source>.gitignore</source>
<document_content>
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

.DS_Store
</document_content>
</document>

<document index="2">
<source>AUTHORS.txt</source>
<document_content>
Adam Twardoch <adam+github@twardoch.com>

</document_content>
</document>

<document index="3">
<source>CHANGELOG.md</source>
<document_content>
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Comprehensive test suite with Pytest
  - Unit tests for core functionality
  - Integration tests for CLI
  - Test data generation utilities
- Type hints throughout the codebase
- Pre-commit hooks for code quality (Ruff, Mypy)
- GitHub Actions CI/CD workflow
- Development documentation in README
- Modern Python packaging with pyproject.toml

### Changed
- Migrated from setup.py to pyproject.toml with Hatch build system
- Integrated hatch-vcs for Git tag-based versioning
- Replaced manual code formatting with Ruff
- Enhanced code quality with static type checking (Mypy)
- Updated Python requirement to >=3.9
- Improved CLI error handling and help messages
- Modernized project structure and documentation

### Fixed
- Type safety issues throughout the codebase
- Various code style inconsistencies

### Removed
- Obsolete setup.py file
- requirements.txt (dependencies now in pyproject.toml)

## [0.1.0] - 2022-01-14

### Added
- Initial release of OpenType Hinting Freezer
- Core functionality to freeze TrueType hinting at specific PPM sizes
- Command-line interface `pyfthintfreeze`
- Support for TTF fonts (OTF support is experimental)
- Multiple rendering modes: LCD, LCD-V, mono, light
- Variable font support (basic)
- TrueType Collection (TTC) support
- Apache 2.0 license

[Unreleased]: https://github.com/twardoch/fonttools-opentype-hinting-freezer/compare/v0.1.0...HEAD
[0.1.0]: https://github.com/twardoch/fonttools-opentype-hinting-freezer/releases/tag/v0.1.0
</document_content>
</document>

<document index="4">
<source>CONTRIBUTORS.txt</source>
<document_content>
Adam Twardoch <adam+github@twardoch.com>
Just van Rossum

</document_content>
</document>

<document index="5">
<source>GITHUB_WORKFLOWS_SETUP.md</source>
<document_content>
# GitHub Workflows Setup Instructions

Due to GitHub App permissions restrictions, the workflow files couldn't be created directly in the `.github/workflows/` directory. Please follow these steps to set up the GitHub Actions workflows:

## 1. Create GitHub Workflows Directory

In your local repository, create the GitHub workflows directory:

```bash
mkdir -p .github/workflows
```

## 2. Move Workflow Files

Copy the workflow files from the `github-workflows/` directory to the `.github/workflows/` directory:

```bash
cp github-workflows/ci.yml .github/workflows/ci.yml
cp github-workflows/release.yml .github/workflows/release.yml
```

## 3. Configure PyPI Token (for automated releases)

To enable automated PyPI publishing, you'll need to set up a PyPI token:

1. Go to your repository settings on GitHub
2. Navigate to "Secrets and variables" → "Actions"
3. Add a new repository secret named `PYPI_TOKEN`
4. Get your PyPI token from https://pypi.org/manage/account/token/
5. Paste the token value (including the `pypi-` prefix)

## 4. Commit and Push

```bash
git add .github/workflows/
git commit -m "Add GitHub Actions workflows for CI/CD"
git push origin main
```

## 5. Test the Setup

### Test CI Pipeline
1. Create a feature branch
2. Make a small change
3. Push the branch
4. Create a pull request
5. The CI pipeline should run automatically

### Test Release Pipeline
1. Ensure all tests pass
2. Create and push a git tag:
   ```bash
   git tag -a v1.0.0 -m "Release v1.0.0"
   git push origin v1.0.0
   ```
3. The release pipeline should run automatically

## Workflow Features

### CI Pipeline (`ci.yml`)
- **Triggers**: Push to main, Pull requests to main
- **Tests**: Python 3.9-3.12 on Linux/macOS/Windows
- **Checks**: Linting, formatting, type checking, tests
- **Coverage**: Reports coverage to Codecov

### Release Pipeline (`release.yml`)
- **Triggers**: Push of tags matching `v*` pattern
- **Builds**: Python packages (wheel/sdist) and standalone binaries
- **Publishes**: To PyPI automatically
- **Releases**: Creates GitHub release with artifacts

### Binary Artifacts
The release pipeline creates standalone binaries for:
- `pyfthintfreeze-linux-x86_64`
- `pyfthintfreeze-macos-x86_64`
- `pyfthintfreeze-windows-x86_64.exe`

## Troubleshooting

### If CI fails:
1. Check the Actions tab in your GitHub repository
2. Look for error messages in the workflow logs
3. Ensure all dependencies are properly specified in `pyproject.toml`

### If release fails:
1. Verify the `PYPI_TOKEN` secret is correctly set
2. Check that the git tag follows semantic versioning (`v1.0.0`)
3. Ensure the repository has proper write permissions

### If binary builds fail:
1. Check that PyInstaller can build the application locally
2. Verify all dependencies are properly bundled
3. Test the binary generation script manually

## Manual Alternative

If you prefer not to use GitHub Actions, you can still use the local scripts:

```bash
# Run tests and build locally
./scripts/build.sh

# Create release locally
./scripts/release.sh v1.0.0

# Upload to PyPI manually
hatch build
twine upload dist/*
```
</document_content>
</document>

<document index="6">
<source>IMPLEMENTATION_SUMMARY.md</source>
<document_content>
# Implementation Summary: Git-Tag-Based Semversioning and CI/CD System

## ✅ What Has Been Implemented

### 1. Git-Tag-Based Semversioning System
- **Version Management**: Uses `hatch-vcs` to automatically extract version from git tags
- **Format**: Supports semantic versioning (`v1.0.0`, `v1.0.1`, `v2.0.0`)
- **Pre-releases**: Supports alpha/beta/rc versions (`v1.0.0-alpha`, `v1.0.0-beta`)
- **Auto-detection**: Version automatically determined from git repository state

### 2. Local Build and Release Scripts
- **`scripts/build.sh`**: Complete build pipeline with quality checks and testing
- **`scripts/test.sh`**: Comprehensive test runner with all test types
- **`scripts/release.sh`**: Automated release creation with git tag validation
- **All scripts**: Made executable and include proper error handling

### 3. Comprehensive Test Suite
- **`tests/conftest.py`**: Pytest configuration with fixtures and test data setup
- **`tests/test_functionality.py`**: Core functionality tests
- **`tests/test_error_handling.py`**: Error handling and edge case tests
- **`tests/test_performance.py`**: Performance benchmarks and memory usage tests
- **Test Categories**: Fast tests, slow tests, and comprehensive coverage

### 4. Enhanced Project Configuration
- **`pyproject.toml`**: Updated with comprehensive test configuration
- **Test Commands**: Added `test-fast`, `test-slow`, and improved `check` command
- **Dependencies**: Added `psutil` for performance testing
- **Pytest Configuration**: Markers for slow tests and proper test discovery

### 5. GitHub Actions Workflows (Templates)
- **`github-workflows/ci.yml`**: CI pipeline for continuous integration
- **`github-workflows/release.yml`**: Release pipeline with multiplatform builds
- **Features**: Tests on Python 3.9-3.12, Linux/macOS/Windows, automatic PyPI publishing

### 6. Multiplatform Binary Building
- **Linux**: `pyfthintfreeze-linux-x86_64`
- **macOS**: `pyfthintfreeze-macos-x86_64`
- **Windows**: `pyfthintfreeze-windows-x86_64.exe`
- **PyInstaller**: Configured for standalone executable creation

### 7. Documentation
- **`README_DEVELOPMENT.md`**: Comprehensive development guide
- **`GITHUB_WORKFLOWS_SETUP.md`**: Step-by-step workflow setup instructions
- **`IMPLEMENTATION_SUMMARY.md`**: This summary document

## 🔧 How It Works

### Local Development Workflow
```bash
# Setup
python3 -m venv .venv
source .venv/bin/activate
pip install -e .[dev]

# Development
hatch run check          # Run all quality checks
hatch run test-fast      # Run fast tests
hatch run test           # Run all tests
hatch run test-slow      # Run performance tests

# Build and test
./scripts/build.sh       # Complete build pipeline
./scripts/test.sh        # Test-only pipeline
```

### Release Workflow
```bash
# Automated release
./scripts/release.sh v1.0.0

# Manual release
git tag -a v1.0.0 -m "Release v1.0.0"
git push origin v1.0.0
```

### CI/CD Pipeline
1. **Continuous Integration**: Runs on every push/PR to main
2. **Release Pipeline**: Triggers on git tag push (`v*` pattern)
3. **Multiplatform**: Tests and builds on Linux, macOS, Windows
4. **Automatic**: PyPI publishing and GitHub release creation

## 🚀 Benefits

### For Developers
- **Consistent Versioning**: Git tags automatically control version numbers
- **Quality Assurance**: Comprehensive testing before releases
- **Easy Releases**: One command creates and pushes release tags
- **Fast Feedback**: Separate fast/slow test categories

### For Users
- **Multiple Install Options**: PyPI package and standalone binaries
- **Reliable Releases**: Automated testing ensures quality
- **Cross-platform**: Works on Linux, macOS, and Windows
- **Easy Installation**: No Python environment required for binaries

### For Maintainers
- **Automated Publishing**: No manual PyPI uploads
- **Consistent Process**: Same workflow for all releases
- **Quality Gates**: Tests must pass before release
- **Artifact Management**: All binaries and packages in one place

## 📋 Next Steps Required

### 1. GitHub Workflows Setup
Due to GitHub App permissions, the workflows need manual setup:
```bash
mkdir -p .github/workflows
cp github-workflows/ci.yml .github/workflows/ci.yml
cp github-workflows/release.yml .github/workflows/release.yml
git add .github/workflows/
git commit -m "Add GitHub Actions workflows"
git push origin main
```

### 2. PyPI Token Configuration
For automated PyPI publishing:
1. Get PyPI token from https://pypi.org/manage/account/token/
2. Add as `PYPI_TOKEN` secret in GitHub repository settings
3. Token should include the `pypi-` prefix

### 3. Test the System
```bash
# Test local build
./scripts/build.sh

# Test release creation
./scripts/release.sh v1.0.0

# Verify CI pipeline runs on the created tag
```

## 🎯 Key Features

### Semversioning
- ✅ Git tag-based version extraction
- ✅ Semantic versioning support
- ✅ Pre-release version support
- ✅ Automatic version detection

### Testing
- ✅ Unit tests for core functionality
- ✅ Integration tests for CLI
- ✅ Error handling tests
- ✅ Performance benchmarks
- ✅ Fast/slow test separation

### Build System
- ✅ Local build scripts
- ✅ Automated release scripts
- ✅ Quality checks integration
- ✅ Cross-platform compatibility

### CI/CD
- ✅ Continuous Integration pipeline
- ✅ Automated release pipeline
- ✅ Multiplatform testing
- ✅ Binary artifact creation
- ✅ PyPI publishing automation

### Distribution
- ✅ Python package (wheel/sdist)
- ✅ Standalone binaries
- ✅ GitHub releases
- ✅ PyPI distribution

## 🔄 Maintenance

### Regular Tasks
- Run `hatch run test` before releases
- Update dependencies periodically
- Monitor CI/CD pipeline health
- Review and update test coverage

### Version Updates
- Create git tags for new versions
- Follow semantic versioning principles
- Update CHANGELOG.md for each release
- Test release process on feature branches

This implementation provides a complete, production-ready git-tag-based semversioning system with comprehensive CI/CD infrastructure.
</document_content>
</document>

<document index="7">
<source>LICENSE</source>
<document_content>
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

</document_content>
</document>

<document index="8">
<source>PLAN.md</source>
<document_content>
# OpenType Hinting Freezer - Improvement Plan

## Executive Summary

This document outlines a comprehensive plan to improve the OpenType Hinting Freezer project, focusing on stability, code quality, deployment readiness, and user experience. The project has recently undergone modernization with new build tools and testing infrastructure. This plan builds upon that foundation to create a more robust and maintainable tool.

## Current State Analysis

### Strengths
- Core functionality is working and produces valid output fonts
- Modern Python packaging with pyproject.toml and Hatch
- Basic test infrastructure is in place
- Type hints have been added throughout
- Code formatting and linting with Ruff
- CI/CD pipeline with GitHub Actions
- Clear documentation and examples

### Areas for Improvement
1. **Test Coverage**: Current tests are minimal and don't cover edge cases
2. **Error Handling**: Limited error handling for malformed fonts or invalid inputs
3. **CFF/OTF Support**: Documented as "buggy" - needs investigation and fixes
4. **Variable Font Support**: Only basic implementation exists
5. **Performance**: No optimization for large fonts or batch processing
6. **User Experience**: Limited feedback during processing, no progress indicators
7. **Deployment**: Not yet published to PyPI
8. **Documentation**: Missing API documentation and advanced usage examples

## Detailed Improvement Plan

### Phase 1: Stability and Reliability (Weeks 1-2)

#### 1.1 Comprehensive Error Handling
**Goal**: Ensure the tool handles all error cases gracefully and provides helpful error messages.

**Implementation**:
- Add try-except blocks around all file I/O operations with specific error messages
- Validate font files before processing (check magic bytes, basic structure)
- Add parameter validation (PPM ranges, valid modes, etc.)
- Create custom exception classes for different error scenarios
- Implement proper cleanup on errors (close file handles, free FreeType resources)

**Code locations to modify**:
- `hintingfreezer.py:read_from_path()` - Add file validation
- `hintingfreezer.py:FontHintFreezer.__init__()` - Add font validation
- `hintingfreezer.py:freezehinting()` - Add parameter validation

#### 1.2 Expand Test Coverage
**Goal**: Achieve >90% test coverage with comprehensive edge case testing.

**Implementation**:
- Create test fonts with various characteristics:
  - Fonts with different table structures
  - Malformed fonts (for error testing)
  - Variable fonts with multiple axes
  - CFF/OTF test fonts
  - Large fonts with many glyphs
- Add unit tests for each method in FontHintFreezer
- Add integration tests for different font types and parameters
- Add performance benchmarks
- Implement property-based testing for parameter combinations

**New test files to create**:
- `tests/test_error_handling.py`
- `tests/test_variable_fonts.py`
- `tests/test_cff_fonts.py`
- `tests/test_performance.py`
- `tests/conftest.py` (pytest fixtures)

#### 1.3 Fix CFF/OTF Support
**Goal**: Make CFF font processing as reliable as TTF processing.

**Investigation needed**:
- Profile current CFF processing to identify bugs
- Compare output with reference implementations
- Test with various CFF fonts (Type 1, CFF2)

**Potential fixes**:
- Review `draw_glyph_to_ps_glyph()` implementation
- Ensure proper CharString creation and indexing
- Fix any coordinate transformation issues
- Handle CFF-specific hinting differently if needed

### Phase 2: Feature Enhancement (Weeks 3-4)

#### 2.1 Improve Variable Font Support
**Goal**: Full support for variable fonts with proper instance freezing.

**Implementation**:
- Parse and validate fvar table comprehensively
- Support named instances
- Allow freezing at specific instances
- Preserve or remove variation tables as appropriate
- Add tests for common variable fonts

**New features**:
- `--instance` flag to freeze named instances
- `--keep-variations` flag to preserve var tables
- Better error messages for invalid axis values

#### 2.2 Add Progress Indicators
**Goal**: Provide user feedback during processing, especially for large fonts.

**Implementation**:
- Add optional progress bar using `tqdm` or `rich`
- Show current glyph being processed
- Estimate time remaining
- Add `--quiet` flag to suppress output
- Add `--verbose` flag for detailed logging

#### 2.3 Batch Processing Support
**Goal**: Allow processing multiple fonts efficiently.

**Implementation**:
- Accept glob patterns for input files
- Add `--output-dir` flag for batch output
- Process fonts in parallel using multiprocessing
- Add `--jobs` flag to control parallelism
- Create summary report for batch operations

### Phase 3: Code Quality and Architecture (Week 5)

#### 3.1 Refactor Core Architecture
**Goal**: Improve code maintainability and extensibility.

**Refactoring tasks**:
- Split `FontHintFreezer` into smaller, focused classes
- Create abstract base classes for different font flavors
- Implement strategy pattern for different rendering modes
- Separate concerns (file I/O, font processing, CLI)

**New module structure**:
```
opentype_hinting_freezer/
├── __init__.py
├── __main__.py
├── core/
│   ├── __init__.py
│   ├── base.py          # Abstract base classes
│   ├── ttf_processor.py # TTF-specific logic
│   ├── cff_processor.py # CFF-specific logic
│   └── metrics.py       # Metric calculations
├── cli/
│   ├── __init__.py
│   ├── parser.py        # Argument parsing
│   └── reporter.py      # Progress/output handling
├── utils/
│   ├── __init__.py
│   ├── validation.py    # Input validation
│   └── io.py           # File operations
└── hintingfreezer.py    # Legacy compatibility wrapper
```

#### 3.2 Improve Type Safety
**Goal**: Achieve 100% type coverage with strict mypy checking.

**Tasks**:
- Add missing type annotations
- Use TypedDict for complex dictionaries
- Add Protocol types for duck-typed interfaces
- Enable strict mypy mode
- Fix all type errors

#### 3.3 Documentation Enhancement
**Goal**: Comprehensive documentation for users and developers.

**Documentation tasks**:
- Add docstrings to all public functions/classes
- Create API documentation with Sphinx
- Add architecture documentation
- Create troubleshooting guide
- Add more usage examples
- Document performance characteristics

### Phase 4: Deployment and Distribution (Week 6)

#### 4.1 PyPI Publishing Preparation
**Goal**: Prepare for initial PyPI release.

**Tasks**:
- Ensure all metadata in pyproject.toml is complete
- Create release checklist
- Set up automated releases via GitHub Actions
- Test package in clean environments
- Create Docker image for consistent environment

#### 4.2 Platform Testing
**Goal**: Ensure compatibility across platforms.

**Testing matrix**:
- Python versions: 3.9, 3.10, 3.11, 3.12, 3.13
- Operating systems: Linux, macOS, Windows
- Architectures: x86_64, ARM64
- Font formats: TTF, OTF, TTC, Variable fonts

#### 4.3 Performance Optimization
**Goal**: Optimize for large fonts and batch processing.

**Optimization areas**:
- Profile code to identify bottlenecks
- Optimize FreeType usage (reuse objects where possible)
- Implement caching for repeated operations
- Use numpy for coordinate transformations if beneficial
- Add option to process glyphs in parallel

### Phase 5: User Experience (Week 7)

#### 5.1 Improve CLI Interface
**Goal**: Make the tool more intuitive and user-friendly.

**Enhancements**:
- Add interactive mode for parameter selection
- Provide better default values
- Add `--dry-run` flag to preview operations
- Implement config file support
- Add shell completion scripts

#### 5.2 GUI Development (Optional)
**Goal**: Create simple GUI for non-technical users.

**Options**:
- Web interface using Flask/FastAPI
- Desktop GUI using tkinter or PyQt
- Integrate with existing font tools

### Phase 6: Community and Ecosystem (Week 8)

#### 6.1 Integration with Font Tools Ecosystem
**Goal**: Make the tool work seamlessly with other font tools.

**Integrations**:
- Add fontTools plugin architecture support
- Create fontbakery check for frozen hints
- Add support for UFO format
- Integrate with font editors (RoboFont, Glyphs)

#### 6.2 Community Building
**Goal**: Foster community adoption and contributions.

**Tasks**:
- Create contribution guidelines
- Set up issue templates
- Add code of conduct
- Create discussion forum or Discord
- Write blog posts about use cases
- Present at font technology conferences

## Implementation Priority

1. **Critical** (Must have for stable release):
   - Comprehensive error handling
   - Expanded test coverage
   - Fix CFF/OTF support
   - PyPI publishing

2. **High** (Should have for good UX):
   - Progress indicators
   - Better variable font support
   - Performance optimization
   - Comprehensive documentation

3. **Medium** (Nice to have):
   - Batch processing
   - Architecture refactoring
   - GUI development
   - Platform-specific optimizations

4. **Low** (Future considerations):
   - Tool ecosystem integrations
   - Advanced features
   - Specialized use cases

## Success Metrics

- Test coverage > 90%
- Zero crashes on malformed input
- Processing speed < 1 second per 1000 glyphs
- PyPI downloads > 100/month
- GitHub stars > 50
- Active community contributors > 3

## Risk Mitigation

1. **FreeType API changes**: Pin FreeType version, add compatibility layer
2. **Font format evolution**: Stay updated with OpenType spec changes
3. **Performance regression**: Add benchmark suite to CI
4. **Breaking changes**: Follow semantic versioning strictly
5. **Dependency conflicts**: Use minimal dependencies, test extensively

## Conclusion

This improvement plan provides a roadmap to transform the OpenType Hinting Freezer from a functional prototype into a production-ready tool. By focusing on stability first, then features and user experience, we can build a tool that serves the font development community well while maintaining high code quality standards.
</document_content>
</document>

<document index="9">
<source>README.md</source>
<document_content>
# OpenType Hinting Freezer (`pyfthintfreeze`)

`pyfthintfreeze` is a command-line tool and Python 3.x library that applies the TrueType hinting of an existing OpenType font to its contours at a specified Pixels-Per-EM (PPM) size. It then outputs a new font with these modified, "frozen" contours. This process effectively "bakes in" the hinting adjustments for a specific size directly into the font's outlines.

The tool leverages the FreeType library to execute the font's hinting instructions and extract the resulting pixel-fitted outlines. While it works best with TTF (TrueType flavored) fonts, basic support for OTF (CFF flavored) fonts is present but may be buggy.

## Who is this tool for?

This tool is designed for:

*   **Font Developers & Typographers:** Who need to ensure consistent and high-quality font rendering at specific, critical sizes.
*   **Graphics Engineers & Application Developers:** Who work in environments where dynamic font hinting might be inconsistent, disabled, or unavailable, and require predictable text display.
*   **Web Designers & Developers:** Who want to serve web fonts optimized for particular sizes, ensuring sharp and clear text across different browsers and platforms.
*   **Embedded Systems Developers:** Where font rendering capabilities might be limited, and pre-rendered or size-specific adjustments are necessary.

## Why is it useful?

*   **Predictable Rendering:** By "freezing" hints into outlines for a specific PPM, you achieve highly predictable glyph shapes at that size, minimizing variations across different rendering engines.
*   **Improved Readability:** For small text sizes, especially on lower-resolution displays, baked-in hinting can significantly improve clarity and legibility.
*   **Performance:** In some scenarios, using fonts with pre-applied hinting can be more performant as the rendering engine doesn't need to execute complex hinting instructions dynamically.
*   **Workaround for Limited Hinters:** Useful when targeting platforms with poor or no support for interpreting advanced TrueType hinting.

## Installation

You can install `opentype-hinting-freezer` from PyPI or directly from GitHub.

**From PyPI (recommended):**

```bash
pip install opentype-hinting-freezer
```

**From GitHub (latest version):**

```bash
pip install git+https://github.com/twardoch/fonttools-opentype-hinting-freezer.git
```

**Local installation (for development or direct use):**

1.  Clone the repository:
    ```bash
    git clone https://github.com/twardoch/fonttools-opentype-hinting-freezer.git
    cd fonttools-opentype-hinting-freezer
    ```
2.  Install (preferably in a virtual environment):
    ```bash
    # Using pip
    pip install .

    # Or with uv (see Development Setup for installing uv)
    uv pip install .
    ```

## Usage

`pyfthintfreeze` can be used as a command-line tool or as a Python library.

### Command-Line Interface (CLI)

The primary interface is the `pyfthintfreeze` command-line tool.

```
$ pyfthintfreeze --help
NAME
    pyfthintfreeze - OpenType font hinting freezer.

SYNOPSIS
    pyfthintfreeze FONTPATH <flags>

DESCRIPTION
    A tool that applies the hinting of an OT font
    to the contours at a specified PPM size,
    and outputs the font with modified contours.
    (Works better with TTF, OTF support is buggy)

    Example:
    pyfthintfreeze font.ttf --ppm=14 --mode="mono"

POSITIONAL ARGUMENTS
    FONTPATH
        Path to an OTF, TTF, or TTC file.

FLAGS
    --out=OUT
        Output path for the modified font. If absent, an automatic name is generated
        in the same directory as the input font (e.g., `font.fhf-12-mono.ttf`).
    --ppm=PPM
        The Pixels-Per-EM (PPM) size at which the hinting should be applied.
        If not provided, the font's units-per-EM will be used (effectively no scaling, which might not be what you want for visual "freezing").
    --subfont=SUBFONT
        The index of the subfont to process in a TTC (TrueType Collection) file.
        Default: 0.
    --var=VAR
        Variable font location as a dictionary string (e.g., '{"wght": 700, "wdth": 100}').
        This is applied if the font is a variable font and has an 'fvar' table.
        Example: --var='{"wght":750}'
    --mode=MODE
        Hinting mode for FreeType rendering. Options:
        - "lcd" (default): Subpixel anti-aliasing for LCD screens (horizontal RGB).
        - "lcdv": Vertical LCD subpixel anti-aliasing (vertical RGB).
        - "mono": Monochrome (black and white) rendering, aliased.
        - "light": Lighter anti-aliasing, suitable for high-DPI screens or when less aggressive hinting is desired.
```

**Example CLI Usage:**

To process `MyFont.ttf` at 16 PPM using LCD hinting mode and save it as `MyFont-frozen-16lcd.ttf`:

```bash
pyfthintfreeze MyFont.ttf --ppm=16 --mode="lcd" --out MyFont-frozen-16lcd.ttf
```

If `--out` is omitted, the output will be, for example, `MyFont.fhf-16-lcd.ttf` in the same directory as `MyFont.ttf`.

### Programmatic Usage (Python Library)

You can use `opentype-hinting-freezer` directly in your Python scripts.

**Import the main function:**

```python
from opentype_hinting_freezer import freezehinting
```

**Function Signature:**

```python
freezehinting(
    fontpath: Union[str, Path],
    out: Optional[Union[str, Path]] = None,
    ppm: Optional[int] = None,
    subfont: int = 0,
    var: Optional[Dict[str, float]] = None,
    mode: str = "lcd"
) -> None
```

**Parameters:**

*   `fontpath`: Path to the input OpenType font file (TTF, OTF, TTC).
*   `out` (optional): Path for the output (frozen) font. If `None`, an automatic name is generated (e.g., `font.fhf-PPM-MODE.suffix`).
*   `ppm` (optional): The Pixels-Per-EM size. If `None`, the font's units-per-EM will be used by `FontHintFreezer` (effectively applying hinting at UPM scale, which means outlines might not change visually unless UPM is very small). For visual freezing, a typical screen PPM (e.g., 10-48) is expected.
*   `subfont` (optional): Index of the subfont in a TrueType Collection (`.ttc`). Defaults to 0.
*   `var` (optional): A dictionary specifying the variable font instance location, e.g., `{'wght': 700, 'wdth': 100}`. Applied if the font is variable.
*   `mode` (optional): Hinting mode. One of `"lcd"` (default), `"lcdv"`, `"mono"`, `"light"`.

**Example Python Script:**

```python
from opentype_hinting_freezer import freezehinting
from pathlib import Path

input_font = Path("path/to/your/Font.ttf")
output_font = Path("path/to/your/Font-frozen.ttf")
target_ppm = 12
hinting_mode = "mono"  # or "lcd", "lcdv", "light"
variable_settings = {"wght": 500} # Optional, for variable fonts

try:
    freezehinting(
        fontpath=input_font,
        out=output_font,
        ppm=target_ppm,
        mode=hinting_mode,
        var=variable_settings # Pass None or omit if not a variable font or no specific instance needed
    )
    print(f"Successfully froze hints for {input_font.name} to {output_font.name}")
except Exception as e:
    print(f"An error occurred: {e}")

```

## Technical Details

### How the Code Works

The core logic of `pyfthintfreeze` revolves around using the FreeType library to render glyphs with their native hinting instructions at a specific PPM, then capturing these hinted outlines and saving them back into a new font using `fontTools`.

1.  **Initialization (`freezehinting` function in `hintingfreezer.py`):**
    *   The main `freezehinting()` function is the primary entry point for both CLI and library usage.
    *   It reads the font data from the given `fontpath`.
    *   It instantiates `FontHintFreezer`.

2.  **`FontHintFreezer` Class:**
    *   **`__init__(font_data, font_number, ppm, render_mode)`:**
        *   Loads the font into two objects:
            *   A `fontTools.ttLib.TTFont` object: Used for inspecting font tables, manipulating glyph data, and saving the modified font.
            *   A `freetype.Face` object: Used for accessing FreeType's hinting and rendering capabilities.
        *   Sets the character size on the `ftFace` using `ftFace.set_char_size(ppm * 64, ...)`. This tells FreeType the target PPM for hinting.
        *   Calculates a `rescale_glyphs` transformation matrix and applies it using `ftFace.set_transform()`. This is crucial for scaling the hinted outlines from FreeType's internal grid-fitted representation back to the font's original units-per-EM (UPM) space. The outlines are hinted at PPM, but stored in font units.
        *   Determines the FreeType load flag (e.g., `FT_LOAD_TARGET_LCD`, `FT_LOAD_TARGET_MONO`) based on the `render_mode`.
    *   **`set_var_location(var_location: Dict[str, float])`:**
        *   If the font has an `fvar` table (i.e., it's a variable font) and `var_location` is provided, this method sets the FreeType instance to the specified design coordinates using `FT_Set_Var_Design_Coordinates`. This ensures hinting is applied for that specific instance.
    *   **`freeze_hints()`:**
        *   This is the main method that processes glyphs.
        *   It iterates through all glyph names in the font.
        *   **For TrueType (`glyf`) Fonts:**
            *   Calls `draw_glyph_to_tt_glyph()` for each glyph.
            *   `prep_glyph()`:
                *   Loads the glyph into FreeType's glyph slot using `self.ftFace.load_glyph(glyph_id, FT_LOAD_RENDER | self.ft_flag)`. The `FT_LOAD_RENDER` flag ensures hinting is applied.
                *   Extracts hinted horizontal metrics (advance width, left side bearing) from `self.ftFace.glyph.metrics` and scales them back to font units.
            *   `draw_glyph_to_point_pen(pen)`:
                *   This method is responsible for extracting the hinted outline coordinates.
                *   It iterates over the contours, points, and tags from `self.ftFace.glyph.outline`. FreeType provides these coordinates already hinted and grid-fitted to the PPM scale.
                *   It translates these FreeType outline structures into segment commands (beginPath, addPoint, endPath) for a `fontTools` `PointPen`. The points are already scaled by the transformation matrix set earlier.
            *   A `TTGlyphPointPen` (a type of `PointPen`) is used to collect these outline points and construct a new `fontTools` `Glyph` object.
            *   The newly created `Glyph` object (containing the hinted outline) replaces the original glyph in the `ttFont['glyf']` table.
            *   The scaled hinted metrics are updated in the `ttFont['hmtx']` table.
        *   **For CFF (OTF) Fonts (Experimental/Buggy):**
            *   Calls `draw_glyph_to_ps_glyph()` for each glyph.
            *   The process is similar but uses a `T2CharStringPen` to attempt to reconstruct a Type 2 charstring from the hinted outlines. This is more complex and less robust than handling TrueType outlines. CFF hinting models are different, and "freezing" them this way might not always yield expected results.
    *   **Font Saving:** After all glyphs are processed, the modified `ttFont` object (with hinted outlines and metrics) is saved to the specified output file path.

### Key Libraries and Tools

*   **`fontTools`**: The cornerstone for OpenType and TrueType font manipulation in Python. Used for reading, parsing, modifying, and saving font files.
*   **`freetype-py`**: Python bindings for the FreeType library. FreeType is the engine that performs the actual font rendering and hinting.
*   **`python-fire`**: Used to quickly generate the command-line interface from the `freezehinting` function.
*   **`Hatch`**: The build backend specified in `pyproject.toml`, used for managing project builds, versions, and running tasks (like linting, testing).
*   **`uv`**: A fast Python package installer and virtual environment manager, recommended for development.
*   **`Ruff`**: Used for code formatting and linting, ensuring code quality and consistency.
*   **`Mypy`**: A static type checker for Python, helping to catch type errors.
*   **`Pytest`**: The framework used for running automated tests.

### Codebase Structure

*   `opentype_hinting_freezer/`: The main Python package.
    *   `__init__.py`: Makes the directory a package and exports the main `freezehinting` function and `__version__`.
    *   `__main__.py`: Provides the command-line interface (CLI) entry point using `python-fire`. It calls `freezehinting`.
    *   `hintingfreezer.py`: Contains the core logic:
        *   `FontHintFreezer` class: Manages the font loading, FreeType interaction, outline extraction, and modification of `fontTools` objects.
        *   `freezehinting()`: The main public function that orchestrates the process.
*   `tests/`: Contains all automated tests.
    *   `data/`: Test assets, such as `minimal.ttf`.
    *   `generate_minimal_ttf.py`: Script to generate the `minimal.ttf` used in tests.
    *   `test_hintingfreezer_unit.py`: Unit tests for components within `hintingfreezer.py`.
    *   `test_cli_integration.py`: Integration tests for the `pyfthintfreeze` CLI.
*   `assets/`: Contains images used in this README.
*   `pyproject.toml`: Defines project metadata, dependencies, build system (Hatch), and configurations for tools like Ruff and Mypy (via `mypy.ini`).
*   `setup.py`: Legacy setup file, primarily used by `setuptools` for tasks like `get_version()`. Modern packaging relies more on `pyproject.toml`.
*   `mypy.ini`: Configuration for the Mypy static type checker.
*   `.pre-commit-config.yaml`: Configuration for pre-commit hooks, ensuring code quality before commits.
*   `.github/workflows/`: Contains GitHub Actions workflows for continuous integration (CI).

## Contributing

Contributions are highly welcome! Please adhere to the following guidelines to ensure a smooth development process.

### Development Environment Setup

We recommend using `uv` for fast virtual environment and package management, and `hatch` for running development tasks (linting, testing, building), which are configured in `pyproject.toml`.

1.  **Install `uv`**:
    Follow the official instructions to install `uv`: [https://github.com/astral-sh/uv#installation](https://github.com/astral-sh/uv#installation)

2.  **Clone the repository (if you haven't already):**
    ```bash
    git clone https://github.com/twardoch/fonttools-opentype-hinting-freezer.git
    cd fonttools-opentype-hinting-freezer
    ```

3.  **Create and activate a virtual environment using `uv`:**
    ```bash
    uv venv .venv
    source .venv/bin/activate  # On Windows: .venv\Scripts\activate
    ```

4.  **Install dependencies:**
    Install the project in editable mode along with development dependencies:
    ```bash
    uv pip install -e .[dev]
    ```
    This command installs `opentype-hinting-freezer` itself in editable mode, plus all tools needed for development like Ruff, Mypy, and Pytest.

### Running Quality Checks and Tests

Common development tasks are defined as scripts in `pyproject.toml` and can be run with `hatch`.

*   **Formatting**: `hatch run format` (uses Ruff to format code)
*   **Linting**: `hatch run lint` (uses Ruff to check for style issues and potential errors)
*   **Type Checking**: `hatch run typecheck` (uses Mypy to check for type consistency)
*   **Testing**: `hatch run test` (uses Pytest to run all unit and integration tests)
*   **Test Coverage**: `hatch run test-cov` (runs tests and generates a coverage report)
*   **All Checks**: `hatch run check` (runs format, lint, typecheck - a good command to run before committing)
*   **Building**: `hatch run build` (builds source distribution (sdist) and wheel)

### Pre-commit Hooks

This project uses `pre-commit` to automatically run linters and formatters on your code before you commit it. This helps maintain code quality and consistency.

After installing development dependencies (which includes `pre-commit`), install the git hooks:

```bash
pre-commit install
```

Now, the configured hooks (e.g., Ruff for formatting and linting, Mypy for type checking) will run automatically on every `git commit`. If a hook modifies a file, you'll need to `git add` the changes and re-commit.

### Coding Standards

*   Follow **PEP 8** for Python code style. Ruff helps enforce this.
*   Write **clear, commented code** where the logic is not immediately obvious.
*   Ensure code is **well-typed** and passes Mypy checks.
*   **Write tests** for new features or bug fixes. Ensure all tests pass (`hatch run test`).
*   Keep commit messages **clear and descriptive**. Consider using [Conventional Commits](https://www.conventionalcommits.org/) for commit message formatting, although not strictly enforced.

### Submitting Changes

1.  Create a new branch for your feature or bug fix: `git checkout -b my-feature-branch`.
2.  Make your changes, run `hatch run check` and `hatch run test` to ensure everything is okay.
3.  Commit your changes. Pre-commit hooks will run automatically.
4.  Push your branch to GitHub: `git push origin my-feature-branch`.
5.  Open a Pull Request (PR) against the `main` branch of the repository.
6.  Clearly describe your changes in the PR and link to any relevant issues.

## Examples from the Original README

The following examples illustrate the effect of `pyfthintfreeze`.

```
pyfthintfreeze CharisSIL-Regular.ttf --ppm=12 --mode="lcd"
```

Original [CharisSIL-Regular.ttf](https://github.com/google/fonts/blob/main/ofl/charissil/CharisSIL-Regular.ttf) font:

![CharisSIL-Regular](./assets/CharisSIL-Regular.png)

The font with hinting in LCD mode applied at 12 PPM:

![CharisSIL-Regular.fhf-12-lcd.png](./assets/CharisSIL-Regular.fhf-12-lcd.png)

---

```
pyfthintfreeze Roboto-Black.ttf --ppm=12 --mode="mono"
```

Original [Roboto-Black.ttf](https://github.com/google/fonts/blob/main/apache/roboto/static/Roboto-Black.ttf) font:

![Roboto-Black](./assets/Roboto-Black.png)

The font with hinting in monochrome mode applied at 12 PPM:

![Roboto-Black.fhf-12-mono.png](./assets/Roboto-Black.fhf-12-mono.png)


## Credits and License

*   Copyright (c) 2022 by [Adam Twardoch and others](./AUTHORS.txt)
*   Code by [Adam Twardoch and others](./CONTRIBUTORS.txt)
*   Licensed under the [Apache-2.0 License](./LICENSE)

</document_content>
</document>

<document index="10">
<source>README_DEVELOPMENT.md</source>
<document_content>
# Development Guide

## Git Tag Based Semversioning

This project uses git tags for semantic versioning. The version is automatically extracted from git tags using `hatch-vcs`.

### Version Format

- Use semantic versioning: `v1.0.0`, `v1.0.1`, `v1.1.0`, `v2.0.0`
- Pre-release versions: `v1.0.0-alpha`, `v1.0.0-beta`, `v1.0.0-rc1`

### Creating a Release

1. **Local Development Setup**
   ```bash
   python3 -m venv .venv
   source .venv/bin/activate
   pip install -e .[dev]
   ```

2. **Run Tests and Build**
   ```bash
   ./scripts/test.sh
   ./scripts/build.sh
   ```

3. **Create and Push Release Tag**
   ```bash
   ./scripts/release.sh v1.0.0
   ```

### Manual Release Process

If you prefer manual control:

1. **Ensure clean working directory**
   ```bash
   git status
   ```

2. **Run full test suite**
   ```bash
   hatch run test
   hatch run test-cov
   ```

3. **Create and push tag**
   ```bash
   git tag -a v1.0.0 -m "Release v1.0.0"
   git push origin v1.0.0
   ```

4. **GitHub Actions will automatically**:
   - Run tests on all supported platforms
   - Build Python packages (wheel and sdist)
   - Build standalone binaries for Linux, macOS, and Windows
   - Publish to PyPI
   - Create GitHub release with artifacts

## Local Testing

### Quick Tests (fast)
```bash
hatch run test-fast
```

### Full Test Suite (includes slow tests)
```bash
hatch run test
```

### Performance Tests
```bash
hatch run test-slow
```

### Code Quality Checks
```bash
hatch run check
```

### Coverage Report
```bash
hatch run test-cov
```

## CI/CD Pipeline

**⚠️ SETUP REQUIRED**: The GitHub Actions workflows need to be manually set up due to permissions restrictions. See `GITHUB_WORKFLOWS_SETUP.md` for detailed instructions.

### Continuous Integration (CI)

Triggers on:
- Push to `main` branch
- Pull requests to `main` branch

Runs:
- Tests on Python 3.9, 3.10, 3.11, 3.12
- Tests on Linux, macOS, Windows
- Code quality checks (linting, formatting, type checking)
- Test coverage reporting

### Release Pipeline

Triggers on:
- Push of tags matching `v*` pattern

Runs:
- Full test suite on all platforms
- Package building (Python packages)
- Binary building (standalone executables)
- PyPI publishing
- GitHub release creation

## Binary Releases

The CI pipeline automatically creates standalone binaries for:
- Linux x86_64 (`pyfthintfreeze-linux-x86_64`)
- macOS x86_64 (`pyfthintfreeze-macos-x86_64`)
- Windows x86_64 (`pyfthintfreeze-windows-x86_64.exe`)

Users can download these from the GitHub releases page.

## Development Workflow

1. **Clone and setup**
   ```bash
   git clone https://github.com/twardoch/fonttools-opentype-hinting-freezer.git
   cd fonttools-opentype-hinting-freezer
   ./scripts/build.sh
   ```

2. **Make changes**
   - Edit code
   - Add/update tests
   - Update documentation

3. **Test locally**
   ```bash
   hatch run check
   hatch run test
   ```

4. **Commit and push**
   ```bash
   git add .
   git commit -m "Your changes"
   git push origin your-branch
   ```

5. **Create pull request**
   - CI will run automatically
   - Review and merge

6. **Create release** (maintainers only)
   ```bash
   ./scripts/release.sh v1.0.0
   ```

## Troubleshooting

### Version not updating from git tags

If the version isn't being picked up from git tags:

1. Ensure you have `hatch-vcs` installed:
   ```bash
   pip install hatch-vcs
   ```

2. Check that git tags are accessible:
   ```bash
   git tag -l
   git describe --tags
   ```

3. For local development, hatch-vcs will use the current git state

### Tests failing

1. Ensure test data exists:
   ```bash
   python tests/generate_minimal_ttf.py
   ```

2. Check that all dependencies are installed:
   ```bash
   pip install -e .[dev]
   ```

3. Run tests with verbose output:
   ```bash
   hatch run test -v
   ```

### Build failures

1. Clean build artifacts:
   ```bash
   hatch run clean
   ```

2. Reinstall dependencies:
   ```bash
   pip install -e .[dev]
   ```

3. Check for environment issues:
   ```bash
   hatch run build
   ```
</document_content>
</document>

<document index="11">
<source>REFACTOR_FILELIST.txt</source>
<document_content>
48	./llms.txt
46	./assets/CharisSIL-Regular.png
45	./assets/CharisSIL-Regular.fhf-12-lcd.png
41	./assets/Roboto-Black.fhf-12-mono.png
40	./assets/Roboto-Black.png
18	./README.md
11	./LICENSE
10	./PLAN.md
8	./opentype_hinting_freezer/hintingfreezer.py
6	./pyproject.toml
4	./TODO.md
4	./tests/test_cli_integration.py
2	./tests/generate_minimal_ttf.py

</document_content>
</document>

<document index="12">
<source>REFACTOR_SPLITTING.md</source>
<document_content>
# Refactoring Plan: Splitting Large Code Files

## Executive Summary

This document outlines a detailed plan for refactoring the `opentype_hinting_freezer/hintingfreezer.py` file, which currently contains the majority of the core logic for the OpenType Hinting Freezer project. The goal is to split this large file into smaller, more focused modules, improving maintainability, readability, and adherence to the Single Responsibility Principle, while ensuring that all existing functionality remains absolutely intact.

This plan aligns with the "Refactor Core Architecture" goal outlined in the project's `PLAN.md`.

## File to Refactor

-   `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/hintingfreezer.py`

## Current Structure Analysis of `hintingfreezer.py`

The `hintingfreezer.py` file currently encompasses:
-   Necessary imports from `io`, `pathlib`, `fontTools`, and `freetype`.
-   The `renderModeFlags` dictionary, mapping rendering mode strings to FreeType constants.
-   The `FontHintFreezer` class, which is a monolithic class handling:
    -   Font loading and initialization (`__init__`).
    -   Variable font instance setting (`set_var_location`).
    -   Glyph preparation (`prep_glyph`).
    -   Generic outline drawing (`draw_glyph_to_point_pen`, `draw_glyph_to_pen`).
    -   TrueType-specific glyph processing (`draw_glyph_to_tt_glyph`).
    -   CFF-specific glyph processing (`draw_glyph_to_ps_glyph`).
    -   Orchestration of the hint freezing process across all glyphs (`freeze_hints`).
-   The `read_from_path` utility function for reading font file data.
-   The `freezehinting` function, which serves as the main public API and CLI entry point, orchestrating the `FontHintFreezer` class.

## Proposed Splitting Strategy

The core idea is to separate concerns into distinct modules, following the proposed `core/`, `cli/`, and `utils/` structure from `PLAN.md`.

### New Module Structure:

```
opentype_hinting_freezer/
├── __init__.py
├── constants.py                  # New: For shared constants like renderModeFlags
├── core/                         # New: Core logic for font processing
│   ├── __init__.py
│   ├── font_freezer.py           # Renamed/Refactored: Main FontHintFreezer class (orchestrator)
│   └── glyph_processors.py       # New: Classes for TTF and CFF glyph processing
├── cli/                          # New: Command-line interface logic
│   ├── __init__.py
│   └── main_cli.py               # New: Contains the freezehinting function (CLI entry point)
└── utils/                        # New: General utility functions
    ├── __init__.py
    └── font_io.py                # New: For font file I/O operations
```

## Detailed Plan for Junior Developer

Follow these steps meticulously. After each step, ensure the project still builds and, if possible, run relevant tests to verify functionality.

---

### Step 1: Create New Directory Structure

1.  **Create `core` directory:**
    ```bash
    mkdir -p /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/core
    ```
2.  **Create `cli` directory:**
    ```bash
    mkdir -p /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/cli
    ```
3.  **Create `utils` directory:**
    ```bash
    mkdir -p /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/utils
    ```
4.  **Create `__init__.py` in new directories:**
    ```bash
    touch /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/core/__init__.py
    touch /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/cli/__init__.py
    touch /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/utils/__init__.py
    ```

---

### Step 2: Move `renderModeFlags` to `constants.py`

1.  **Create `constants.py`:**
    ```bash
    touch /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/constants.py
    ```
2.  **Move content:**
    *   Open `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/hintingfreezer.py`.
    *   Cut the `renderModeFlags` dictionary definition.
    *   Paste it into `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/constants.py`.
    *   Add necessary imports to `constants.py` if `FT_LOAD_TARGET_LCD`, etc., are not defined there (they are from `freetype`, so `from freetype import *` will be needed).
3.  **Update import in `hintingfreezer.py`:**
    *   In `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/hintingfreezer.py`, add:
        ```python
        from .constants import renderModeFlags
        ```
    *   Remove `from freetype import *` from `hintingfreezer.py` if `renderModeFlags` was the only thing using `FT_LOAD_TARGET_*` constants directly. Otherwise, keep it. (It's used by `FontHintFreezer` directly, so keep it for now).

---

### Step 3: Move `read_from_path` to `utils/font_io.py`

1.  **Create `font_io.py`:**
    ```bash
    touch /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/utils/font_io.py
    ```
2.  **Move content:**
    *   Open `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/hintingfreezer.py`.
    *   Cut the `read_from_path` function definition.
    *   Paste it into `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/utils/font_io.py`.
    *   Add necessary imports to `font_io.py`:
        ```python
        from pathlib import Path
        from typing import Union
        ```
3.  **Update import in `hintingfreezer.py`:**
    *   In `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/hintingfreezer.py`, add:
        ```python
        from ..utils.font_io import read_from_path
        ```
4.  **Update import in `tests/test_hintingfreezer_unit.py`:**
    *   Open `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/test_hintingfreezer_unit.py`.
    *   Change:
        ```python
        from opentype_hinting_freezer.hintingfreezer import read_from_path
        ```
        to:
        ```python
        from opentype_hinting_freezer.utils.font_io import read_from_path
        ```

---

### Step 4: Refactor `FontHintFreezer` and Create Glyph Processors

This is the most involved step.

1.  **Rename `hintingfreezer.py` to `font_freezer.py`:**
    ```bash
    mv /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/hintingfreezer.py /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/core/font_freezer.py
    ```

2.  **Create `glyph_processors.py`:**
    ```bash
    touch /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/core/glyph_processors.py
    ```

3.  **Populate `glyph_processors.py`:**
    *   Open `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/core/glyph_processors.py`.
    *   Add necessary imports:
        ```python
        from typing import Any, Dict, Iterator, List, Optional, Tuple, Mapping
        from fontTools.pens.pointPen import PointToSegmentPen
        from fontTools.pens.t2CharStringPen import T2CharStringPen
        from fontTools.pens.ttGlyphPen import TTGlyphPointPen
        from freetype import Face, GlyphSlot, Matrix, Vector, FT_LOAD_RENDER, FT_Fixed, FT_Set_Var_Design_Coordinates
        ```
    *   Define `BaseGlyphProcessor` (or a `Protocol` if preferred for more strict typing, but for simplicity, an abstract base class is fine for now):
        ```python
        from abc import ABC, abstractmethod

        class BaseGlyphProcessor(ABC):
            def __init__(self, tt_font_instance: Any, ft_face_instance: Face, glyph_set: Mapping[str, Any], ft_flag: int, rescale_metrics: float, rescale_glyphs: int):
                self.ttFont = tt_font_instance
                self.ftFace = ft_face_instance
                self.glyphSet = glyph_set
                self.ft_flag = ft_flag
                self.rescale_metrics = rescale_metrics
                self.rescale_glyphs = rescale_glyphs
                self.ftGlyph: Optional[GlyphSlot] = None
                self.width: int = 0
                self.lsb: int = 0

            def prep_glyph(self, glyph_name: str) -> None:
                glyph_id: int = self.ttFont.getGlyphID(glyph_name)
                self.ftFace.load_glyph(glyph_id, FT_LOAD_RENDER | self.ft_flag)
                self.ftGlyph = self.ftFace.glyph
                self.lsb = int(self.ftGlyph.metrics.horiBearingX * self.rescale_metrics)
                self.width = int(self.ftGlyph.metrics.horiAdvance * self.rescale_metrics)

            def draw_glyph_to_point_pen(self, pen: Any) -> None:
                if not self.ftGlyph:
                    raise RuntimeError("Glyph not prepared. Call prep_glyph first.")
                contours: Iterator[int] = (i + 1 for i in self.ftGlyph.outline.contours)
                points: List[Tuple[int, int]] = self.ftGlyph.outline.points
                flags: List[int] = self.ftGlyph.outline.tags
                curve_type: str = "curve" if any(t & 0x02 for t in flags) else "qcurve"
                from_index: int = 0
                for to_index in contours:
                    c_points: List[Tuple[int, int]] = points[from_index:to_index]
                    c_flags: List[int] = flags[from_index:to_index]
                    pen.beginPath()
                    for i_idx, (pt_x, pt_y) in enumerate(c_points):
                        point_coord: Tuple[int, int] = (pt_x, pt_y)
                        segment_type: Optional[str] = None
                        if not c_flags[i_idx] & 0x01:
                            segment_type = None
                        elif c_flags[i_idx -1] & 0x01:
                            segment_type = "line"
                        else:
                            segment_type = curve_type
                        pen.addPoint(point_coord, segmentType=segment_type)
                    pen.endPath()
                    from_index = to_index

            def draw_glyph_to_pen(self, pen: Any) -> None:
                self.draw_glyph_to_point_pen(PointToSegmentPen(pen))

            @abstractmethod
            def process_glyph(self, glyph_name: str) -> None:
                pass

        class TTFGlyphProcessor(BaseGlyphProcessor):
            def process_glyph(self, glyph_name: str) -> None:
                self.prep_glyph(glyph_name)
                pen = TTGlyphPointPen(glyphSet=self.glyphSet, handleOverflowingTransforms=True)
                self.draw_glyph_to_point_pen(pen)
                self.ttFont["glyf"][glyph_name] = pen.glyph()
                self.ttFont["hmtx"][glyph_name] = (self.width, self.lsb)

        class CFFGlyphProcessor(BaseGlyphProcessor):
            def process_glyph(self, glyph_name: str) -> None:
                cff = self.ttFont["CFF "].cff
                top_dict: Any = cff.topDictIndex[0]
                self.prep_glyph(glyph_name)
                pen = T2CharStringPen(
                    width=self.width, glyphSet=self.glyphSet, roundTolerance=0.5, CFF2=False
                )
                self.draw_glyph_to_pen(pen)
                top_dict.CharStrings.charStringsIndex.items.append(None)
                i: int = len(top_dict.CharStrings.charStringsIndex) - 1
                top_dict.CharStrings.charStringsIndex[i] = pen.getCharString(
                    private=top_dict.Private
                )
                top_dict.CharStrings.charStrings[glyph_name] = i
                self.ttFont["hmtx"][glyph_name] = (self.width, self.lsb)
        ```

4.  **Modify `opentype_hinting_freezer/core/font_freezer.py`:**
    *   Open `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/core/font_freezer.py`.
    *   Remove the `read_from_path` function and the `freezehinting` function (they will be moved in subsequent steps).
    *   Remove the `renderModeFlags` dictionary.
    *   Update imports:
        ```python
        import io
        from pathlib import Path
        from typing import Any, Dict, List, Optional, Mapping, KeysView
        from fontTools.ttLib import TTFont
        from freetype import Face, Matrix, Vector, FT_Fixed, FT_Set_Var_Design_Coordinates, FT_LOAD_TARGET_LCD, FT_LOAD_TARGET_MONO, FT_LOAD_TARGET_LCD_V, FT_LOAD_TARGET_LIGHT

        from ..constants import renderModeFlags as RENDER_MODE_FLAGS # Use alias to avoid conflict
        from .glyph_processors import TTFGlyphProcessor, CFFGlyphProcessor, BaseGlyphProcessor
        ```
    *   Modify the `FontHintFreezer` class:
        *   Remove `glyphName`, `width`, `lsb`, `ftGlyph` attributes from the class definition (they are now part of the glyph processors).
        *   In `__init__`, after setting up `self.ttFont` and `self.ftFace`, determine the font type and instantiate the correct `GlyphProcessor`:
            ```python
            class FontHintFreezer:
                ttFont: TTFont
                ftFace: Face
                glyphSet: Mapping[str, Any]
                glyphNames: KeysView[str]
                upm: int
                ppm: int
                rescale_metrics: float
                rescale_glyphs: int
                ft_flag: int
                _glyph_processor: BaseGlyphProcessor # New attribute

                def __init__(
                    self,
                    font_data: bytes,
                    font_number: int = 0,
                    ppm: Optional[int] = None,
                    render_mode: str = "lcd",
                ) -> None:
                    stream = io.BytesIO(font_data)
                    self.ttFont = TTFont(stream, fontNumber=font_number, lazy=False)
                    stream = io.BytesIO(font_data)
                    self.ftFace = Face(stream, index=font_number)
                    self.glyphSet = self.ttFont.getGlyphSet()
                    self.glyphNames = self.glyphSet.keys()
                    self.upm = self.ftFace.units_per_EM
                    self.ppm = ppm or self.upm
                    self.rescale_metrics = float(self.upm) / float(self.ppm) / 64.0
                    self.rescale_glyphs = int(float(self.upm) / float(self.ppm) / 64.0 * 0x10000)
                    self.ftFace.set_char_size(self.ppm * 64, 0, 72, 0)
                    self.ftFace.set_transform(
                        Matrix(self.rescale_glyphs, 0, 0, self.rescale_glyphs), Vector(0, 0)
                    )
                    self.ft_flag = RENDER_MODE_FLAGS.get(render_mode, FT_LOAD_TARGET_LCD)

                    # Instantiate the correct glyph processor
                    if "glyf" in self.ttFont:
                        self._glyph_processor = TTFGlyphProcessor(
                            self.ttFont, self.ftFace, self.glyphSet, self.ft_flag, self.rescale_metrics, self.rescale_glyphs
                        )
                    elif "CFF " in self.ttFont:
                        cff = self.ttFont["CFF "].cff
                        cff.desubroutinize() # CFF processing needs this
                        self._glyph_processor = CFFGlyphProcessor(
                            self.ttFont, self.ftFace, self.glyphSet, self.ft_flag, self.rescale_metrics, self.rescale_glyphs
                        )
                    else:
                        raise ValueError("Unsupported font type: neither 'glyf' nor 'CFF ' table found.")
            ```
        *   Remove `prep_glyph`, `draw_glyph_to_point_pen`, `draw_glyph_to_pen`, `draw_glyph_to_tt_glyph`, `draw_glyph_to_ps_glyph` methods from `FontHintFreezer`.
        *   Modify `freeze_hints` to delegate to the `_glyph_processor`:
            ```python
            def freeze_hints(self) -> None:
                for glyph_name_loopvar in self.glyphNames:
                    self._glyph_processor.process_glyph(glyph_name_loopvar)
            ```
        *   The `set_var_location` method remains in `FontHintFreezer` as it operates on the `ftFace` and `ttFont` directly.

---

### Step 5: Refactor `freezehinting` to `cli/main_cli.py`

1.  **Create `main_cli.py`:**
    ```bash
    touch /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/cli/main_cli.py
    ```
2.  **Move content:**
    *   Open `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/core/font_freezer.py` (the file that was `hintingfreezer.py`).
    *   Cut the `freezehinting` function definition.
    *   Paste it into `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/cli/main_cli.py`.
    *   Add necessary imports to `main_cli.py`:
        ```python
        from pathlib import Path
        from typing import Optional, Dict, Union
        from ..core.font_freezer import FontHintFreezer
        from ..utils.font_io import read_from_path
        ```
    *   Ensure the `freezehinting` function's docstring and parameters are correct.

3.  **Update `opentype_hinting_freezer/__main__.py`:**
    *   Open `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/__main__.py`.
    *   Change:
        ```python
        from .hintingfreezer import freezehinting
        ```
        to:
        ```python
        from .cli.main_cli import freezehinting
        ```
    *   Modify the `cli()` function to call `fire.Fire(freezehinting)` directly, as `freezehinting` is now the main entry point for the CLI.
        ```python
        import fire
        from typing import List, Any, IO # Keep these if custom_display is still used
        from .cli.main_cli import freezehinting

        def custom_display(lines: List[str], out: IO[Any]) -> None:
            print(*lines, file=out)

        def cli() -> None:
            fire.core.Display = custom_display # Keep this if you want custom display
            fire.Fire(freezehinting)

        if __name__ == "__main__":
            cli()
        ```

---

### Step 6: Update `__init__.py` files

1.  **Update `opentype_hinting_freezer/__init__.py`:**
    *   Open `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/__init__.py`.
    *   Change:
        ```python
        from .hintingfreezer import freezehinting
        ```
        to:
        ```python
        from .cli.main_cli import freezehinting
        ```
    *   This ensures `freezehinting` is still importable from the top-level package.

---

### Step 7: Update `pyproject.toml`

1.  **Update `project.scripts`:**
    *   Open `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/pyproject.toml`.
    *   Under `[project.scripts]`, ensure the `pyfthintfreeze` entry points to the correct CLI function:
        ```toml
        [project.scripts]
        pyfthintfreeze = "opentype_hinting_freezer.cli.main_cli:freezehinting"
        ```
        (Note: If `__main__.py` is still the entry point and calls `cli()`, then `opentype_hinting_freezer.__main__:cli` is correct. The plan assumes `freezehinting` becomes the direct target for `fire.Fire`.)

2.  **Review `tool.hatch.build.targets.wheel`:**
    *   Ensure `packages = ["opentype_hinting_freezer"]` is still correct. This should automatically pick up the new submodules.

---

### Step 8: Update Tests

1.  **Review and update imports in test files:**
    *   `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/test_cli_integration.py`: No direct imports from `hintingfreezer.py`, so this should be fine. It calls the CLI executable.
    *   `/Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/test_hintingfreezer_unit.py`: Already updated `read_from_path`. If any new unit tests are added for `FontHintFreezer` or `GlyphProcessor` classes, their imports will need to be updated accordingly (e.g., `from opentype_hinting_freezer.core.font_freezer import FontHintFreezer`).

2.  **Consider adding new unit tests:**
    *   It would be beneficial to add specific unit tests for `TTFGlyphProcessor` and `CFFGlyphProcessor` to ensure their isolated functionality.

---

### Step 9: Verification

1.  **Run quality checks:**
    ```bash
    hatch run check
    ```
    Address any linting or type-checking errors.

2.  **Run tests:**
    ```bash
    hatch run test
    ```
    Ensure all existing tests pass.

3.  **Manual CLI testing:**
    *   Run the CLI with various font types (TTF, OTF, TTC if available) and parameters (`--ppm`, `--mode`, `--out`, `--var`).
    *   Verify that the output fonts are generated correctly and behave as expected.

---

## Important Considerations for Junior Developer

*   **Relative Imports:** Pay extremely close attention to relative imports (`.`, `..`) when moving code between modules. A common mistake is incorrect pathing.
*   **Dependencies:** Ensure that every new or modified Python file has all the necessary `import` statements at the top. If a function or class uses something, it must import it.
*   **Functionality Preservation:** The absolute highest priority is to ensure that the tool's functionality remains identical to its state before refactoring. Test thoroughly after each significant change.
*   **Incremental Changes:** Do not try to do all steps at once. Complete one step, verify, and then move to the next. This makes debugging much easier.
*   **Type Hints:** Preserve and update all existing type hints. If new code is written, add appropriate type hints.
*   **Docstrings:** Ensure that any moved functions or classes retain their docstrings, and update them if their context or parameters change.
*   **Error Handling:** Be mindful of how errors are handled. Ensure that exceptions are still caught and propagated correctly.
*   **Git:** Commit frequently with clear, concise commit messages after each successful small change. This creates a good history and allows for easy rollback if issues arise.

</document_content>
</document>

<document index="13">
<source>TODO.md</source>
<document_content>
# TODO List

## Critical Tasks (For Stable Release)

### Error Handling and Validation
- [ ] Add file validation in `read_from_path()` - check file exists and is readable
- [ ] Validate font file format before processing (magic bytes check)
- [ ] Add parameter validation for PPM (must be positive integer)
- [ ] Add parameter validation for mode (must be one of: lcd, lcdv, mono, light)
- [ ] Create custom exception classes (InvalidFontError, InvalidParametersError, etc.)
- [ ] Add proper cleanup on errors (close file handles, free FreeType resources)
- [ ] Add try-except blocks around all FreeType operations
- [ ] Improve error messages to be more user-friendly

### Testing
- [ ] Create test fonts with various characteristics (CFF, variable, malformed)
- [ ] Add unit tests for `FontHintFreezer.__init__()`
- [ ] Add unit tests for `prep_glyph()` method
- [ ] Add unit tests for `draw_glyph_to_point_pen()` method
- [ ] Add unit tests for `draw_glyph_to_tt_glyph()` method
- [ ] Add unit tests for `draw_glyph_to_ps_glyph()` method
- [ ] Add integration tests for CFF/OTF fonts
- [ ] Add integration tests for variable fonts
- [ ] Add error handling tests (malformed fonts, invalid parameters)
- [ ] Add performance benchmarks
- [ ] Set up code coverage reporting

### CFF/OTF Support
- [ ] Investigate current CFF processing bugs
- [ ] Fix CharString indexing issues in `draw_glyph_to_ps_glyph()`
- [ ] Test with various CFF fonts (Type 1, CFF2)
- [ ] Add comprehensive CFF tests
- [ ] Update documentation to reflect CFF support status

### Deployment
- [ ] Complete all pyproject.toml metadata
- [ ] Test package installation in clean virtual environment
- [ ] Set up automated PyPI releases via GitHub Actions
- [ ] Create initial release (0.2.0)
- [ ] Submit to PyPI

## High Priority Tasks

### Variable Font Support
- [ ] Implement comprehensive fvar table parsing
- [ ] Add support for named instances
- [ ] Add `--instance` CLI flag
- [ ] Add `--keep-variations` flag
- [ ] Test with common variable fonts (Roboto, Inter, etc.)
- [ ] Update documentation with variable font examples

### User Experience
- [ ] Add progress indicator using tqdm or rich
- [ ] Add `--quiet` flag to suppress output
- [ ] Add `--verbose` flag for detailed logging
- [ ] Show estimated time remaining for large fonts
- [ ] Improve help text with more examples

### Documentation
- [ ] Add docstrings to all public methods
- [ ] Create API documentation with Sphinx
- [ ] Add troubleshooting guide
- [ ] Document performance characteristics
- [ ] Add more usage examples to README

### Performance
- [ ] Profile code to identify bottlenecks
- [ ] Optimize FreeType object reuse
- [ ] Investigate numpy for coordinate transformations
- [ ] Add benchmark suite to CI

## Medium Priority Tasks

### Architecture Improvements
- [ ] Split FontHintFreezer into smaller classes
- [ ] Create abstract base class for font processors
- [ ] Separate TTF and CFF processing logic
- [ ] Implement strategy pattern for rendering modes
- [ ] Create proper module structure (core/, cli/, utils/)

### Batch Processing
- [ ] Accept glob patterns for input files
- [ ] Add `--output-dir` flag
- [ ] Implement parallel processing with multiprocessing
- [ ] Add `--jobs` flag for parallelism control
- [ ] Create batch operation summary report

### Type Safety
- [ ] Add missing type annotations
- [ ] Enable strict mypy mode
- [ ] Fix all mypy errors
- [ ] Use TypedDict for complex dictionaries
- [ ] Add Protocol types for interfaces

### CLI Enhancements
- [ ] Add `--dry-run` flag
- [ ] Implement config file support
- [ ] Add shell completion scripts
- [ ] Create interactive mode for parameter selection

## Low Priority Tasks

### Ecosystem Integration
- [ ] Add fontTools plugin support
- [ ] Create fontbakery check
- [ ] Add UFO format support
- [ ] Integrate with font editors

### Advanced Features
- [ ] GUI development (tkinter/PyQt)
- [ ] Web interface (Flask/FastAPI)
- [ ] Docker image creation
- [ ] Platform-specific optimizations

### Community
- [ ] Create detailed contribution guidelines
- [ ] Set up issue templates
- [ ] Add code of conduct
- [ ] Write blog posts about use cases
- [ ] Create video tutorials

## Completed Tasks
- [x] Migrate to pyproject.toml
- [x] Add Ruff for linting/formatting
- [x] Add Mypy for type checking
- [x] Set up GitHub Actions CI
- [x] Add basic pytest infrastructure
- [x] Create initial test files
- [x] Add pre-commit hooks
- [x] Update README with modern practices
</document_content>
</document>

<document index="14">
<source>github-workflows/ci.yml</source>
<document_content>
# GitHub Actions CI Workflow
# File: .github/workflows/ci.yml
# Note: This file should be moved to .github/workflows/ci.yml manually

name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ["3.9", "3.10", "3.11", "3.12"]
        
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install hatch
        pip install -e .[dev]
    
    - name: Run linting
      run: hatch run lint
    
    - name: Run formatting check
      run: hatch run format --check
    
    - name: Run type checking
      run: hatch run typecheck
    
    - name: Run tests
      run: hatch run test
    
    - name: Run tests with coverage
      run: hatch run test-cov
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      if: matrix.os == 'ubuntu-latest' && matrix.python-version == '3.11'
      with:
        file: ./coverage.xml
        fail_ci_if_error: false
</document_content>
</document>

<document index="15">
<source>github-workflows/release.yml</source>
<document_content>
# GitHub Actions Release Workflow
# File: .github/workflows/release.yml
# Note: This file should be moved to .github/workflows/release.yml manually

name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ["3.9", "3.10", "3.11", "3.12"]
        
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install hatch
        pip install -e .[dev]
    
    - name: Run tests
      run: hatch run test

  build:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install hatch build
    
    - name: Build package
      run: hatch build
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: dist
        path: dist/

  build-binaries:
    needs: test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: linux-x86_64
          - os: windows-latest
            target: windows-x86_64
          - os: macos-latest
            target: macos-x86_64
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install hatch pyinstaller
        pip install -e .
    
    - name: Build binary (Linux/macOS)
      if: matrix.os != 'windows-latest'
      run: |
        pyinstaller --onefile --name pyfthintfreeze-${{ matrix.target }} opentype_hinting_freezer/__main__.py
        chmod +x dist/pyfthintfreeze-${{ matrix.target }}
    
    - name: Build binary (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        pyinstaller --onefile --name pyfthintfreeze-${{ matrix.target }}.exe opentype_hinting_freezer/__main__.py
    
    - name: Upload binary artifacts
      uses: actions/upload-artifact@v3
      with:
        name: binaries-${{ matrix.target }}
        path: dist/pyfthintfreeze-*

  publish:
    needs: [test, build]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install hatch twine
    
    - name: Download artifacts
      uses: actions/download-artifact@v3
      with:
        name: dist
        path: dist/
    
    - name: Publish to PyPI
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
      run: |
        twine upload dist/*

  release:
    needs: [test, build, build-binaries, publish]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Download all artifacts
      uses: actions/download-artifact@v3
    
    - name: Create release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          dist/*
          binaries-*/*
        body: |
          ## Changes
          
          See [CHANGELOG.md](https://github.com/twardoch/fonttools-opentype-hinting-freezer/blob/main/CHANGELOG.md) for detailed changes.
          
          ## Installation
          
          ### Python Package
          ```bash
          pip install opentype-hinting-freezer
          ```
          
          ### Standalone Binaries
          Download the appropriate binary for your platform from the assets below.
          
          ## Usage
          
          ```bash
          pyfthintfreeze font.ttf --ppm=14 --mode="mono"
          ```
          
          For more information, see the [README](https://github.com/twardoch/fonttools-opentype-hinting-freezer#readme).
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</document_content>
</document>

<document index="16">
<source>mypy.ini</source>
<document_content>
[mypy]
python_version = 3.9
warn_return_any = True
warn_unused_configs = True
ignore_missing_imports = True

# Per-module settings can be added here if needed
# Example:
# [mypy-somelibrary.*]
# ignore_missing_imports = True

</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/__init__.py
# Language: python

from .hintingfreezer import freezehinting


# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/__main__.py
# Language: python

import fire
from .hintingfreezer import freezehinting

def custom_display((lines: List[str], out: IO[Any])) -> None:

def cli(()) -> None:


# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/opentype_hinting_freezer/hintingfreezer.py
# Language: python

import io
from pathlib import Path
from fontTools.pens.pointPen import PointToSegmentPen
from fontTools.pens.t2CharStringPen import T2CharStringPen
from fontTools.pens.ttGlyphPen import TTGlyphPointPen
from fontTools.ttLib import TTFont
from freetype import *

class FontHintFreezer:
    def __init__((
        self,
        font_data: bytes,
        font_number: int = 0,
        ppm: Optional[int] = None,
        render_mode: str = "lcd",
    )) -> None:
    def set_var_location((self, var_location: Dict[str, float])) -> None:
    def prep_glyph((self)) -> None:
    def draw_glyph_to_point_pen((self, pen: Any)) -> None:
    def draw_glyph_to_pen((self, pen: Any)) -> None:
    def draw_glyph_to_tt_glyph((self)) -> None:
    def draw_glyph_to_ps_glyph((self)) -> None:
    def freeze_hints((self)) -> None:

def __init__((
        self,
        font_data: bytes,
        font_number: int = 0,
        ppm: Optional[int] = None,
        render_mode: str = "lcd",
    )) -> None:

def set_var_location((self, var_location: Dict[str, float])) -> None:

def prep_glyph((self)) -> None:

def draw_glyph_to_point_pen((self, pen: Any)) -> None:

def draw_glyph_to_pen((self, pen: Any)) -> None:

def draw_glyph_to_tt_glyph((self)) -> None:

def draw_glyph_to_ps_glyph((self)) -> None:

def freeze_hints((self)) -> None:

def read_from_path((path: Union[str, Path])) -> bytes:

def freezehinting((fontpath, out=None, ppm=None, subfont=0, var=None, mode="lcd")):
    """ OpenType font hinting freezer \n..."""


<document index="17">
<source>pyproject.toml</source>
<document_content>
[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"

[project]
name = "opentype-hinting-freezer"
dynamic = ["version"]
description = "A tool that applies the hinting of an OT font to the contours at a specified PPM size, and outputs the font with modified contours."
readme = "README.md"
requires-python = ">=3.9"
license = "Apache-2.0"
keywords = ["fonts", "opentype", "hinting"]
authors = [
  { name = "Adam Twardoch", email = "adam+github@twardoch.com" },
]
classifiers = [
  "Development Status :: 4 - Beta",
  "Intended Audience :: Developers",
  "Intended Audience :: Information Technology",
  "Topic :: Text Processing :: Fonts",
  "License :: OSI Approved :: Apache Software License",
  "Operating System :: OS Independent",
  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3.9",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
]
dependencies = [
  "fire>=0.3.1",
  "fontTools>=4.38.0",
  "freetype-py>=2.3.0",
]

[project.urls]
Homepage = "https://github.com/twardoch/fonttools-opentype-hinting-freezer"
Documentation = "https://github.com/twardoch/fonttools-opentype-hinting-freezer#readme"
Repository = "https://github.com/twardoch/fonttools-opentype-hinting-freezer"
Changelog = "https://github.com/twardoch/fonttools-opentype-hinting-freezer/releases"

[project.scripts]
pyfthintfreeze = "opentype_hinting_freezer.__main__:cli"

[tool.hatch.version]
source = "vcs"
path = "opentype_hinting_freezer/__init__.py"

[tool.hatch.build.targets.sdist]
exclude = [
  "/.github",
  "/.gitignore",
  "/assets",
]

[tool.hatch.build.targets.wheel]
packages = ["opentype_hinting_freezer"]

# Updated section for dev dependencies and scripts for Ruff
[project.optional-dependencies]
dev = [
  "ruff",
  "mypy",
  "pre-commit",
  "pytest",
  "pytest-cov",
  "psutil",  # For performance tests
]

[tool.hatch.envs.default]
skip-install = true
dependencies = [
  "ruff",
  "mypy",
  "pytest",       # Added pytest
  "pytest-cov",   # Added pytest-cov
  "pre-commit",
]
features = ["dev"] # Install the 'dev' extras into the default hatch env

[tool.hatch.scripts]
# Code quality
lint = "ruff check ."
format = "ruff format ."
typecheck = "mypy --config-file mypy.ini ."

# Testing
test = "pytest -v"
test-cov = "pytest -v --cov=opentype_hinting_freezer --cov-report=term-missing --cov-report=xml"
test-fast = "pytest -v -m 'not slow'"
test-slow = "pytest -v -m 'slow'"

# Build
build = "hatch build"

# Cleaning (optional, but good practice)
clean = [
    "rm -rf ./*.egg-info",
    "rm -rf ./.eggs",
    "rm -rf ./dist",
    "rm -rf ./.mypy_cache",
    "rm -rf ./.pytest_cache",
    "rm -rf ./htmlcov",
    "rm -rf ./.ruff_cache",
    "find . -name '*.pyc' -delete",
    "find . -name '__pycache__' -type d -delete",
]

# Combined checks (useful for CI or pre-commit)
check = ["hatch run format", "hatch run lint", "hatch run typecheck", "hatch run test-fast"]
# For a full local CI check including build:
# ci-check = ["hatch run check", "hatch run build"]

# Ruff configuration
[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # Pyflakes
    "I",  # isort
    "C90", # mccabe complexity
    "N", # pep8-naming
    "UP", # pyupgrade
    "B", # flake8-bugbear
    "A", # flake8-builtins
    "SIM", # flake8-simplify
    "TID", # flake8-tidy-imports
    "ARG", # flake8-unused-arguments
    "RUF", # Ruff-specific rules
]
ignore = [] # Start with no ignores, E501 (line too long) will be handled by formatter

[tool.ruff]
line-length = 88

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

[tool.ruff.lint.isort]
known-first-party = ["opentype_hinting_freezer"]

# Pytest configuration
[tool.pytest.ini_options]
minversion = "6.0"
addopts = "-ra -q --strict-markers"
testpaths = ["tests"]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
]

# This was previously under [tool.hatch.metadata.hooks.vcs]
# For hatch-vcs, the configuration for writing the version to a file
# is typically done under [tool.hatch.version.file] if using hatchling >= 1.5.0
# or directly in [tool.hatch.version] for older versions.
# Given `source = "vcs"`, `path` is the correct way to specify the file for version updates.
# Let's remove the fallback-version from here as it's not standard in this new structure.
# hatch-vcs has its own fallback mechanisms.
# The `template` option is also not used with `path`. `hatch-vcs` will look for `__version__ = "..."`
# Ensure `opentype_hinting_freezer/__init__.py` contains `__version__ = "0.0.0"` or similar.
# I'll modify `__init__.py` to ensure it has a version string for hatch-vcs.
# The original __init__.py has `__version__ = "0.1.0"`, which is fine.
# `hatch-vcs` will update this line.
# The field in `[tool.hatch.version]` should be `path` not `version-file`.
# Corrected this.
# Also, ensure `hatch-vcs` is in `[build-system].requires`. It is.
# The `dynamic = ["version"]` in `[project]` is correct.
# `[tool.hatch.version]` with `source = "vcs"` and `path` is the modern way.
# Removed the `[tool.hatch.metadata.hooks.vcs]` section as it's superseded by `[tool.hatch.version].path`.
# The `ignore = ["E501"]` for ruff.lint was removed. If `line-length` is set for ruff format,
# and ruff format is run, it should fix line length issues.
# If not, E501 can be added back if preferred over auto-formatting for line length.
# For now, relying on the formatter.
# Added `ruff` to `[tool.hatch.envs.default.dependencies]` as well, for convenience if user runs `hatch shell`.
# The `[tool.hatch.scripts]` for `lint` and `format` are defined.
# The Ruff configuration itself is added to `pyproject.toml` under `[tool.ruff]`.
# This includes line length, selected rules, and formatter settings.
# `known-first-party` for isort is set.
# This should correctly set up pyproject.toml and configure Ruff.

</document_content>
</document>

<document index="18">
<source>scripts/build.sh</source>
<document_content>
#!/bin/bash
# this_file: scripts/build.sh
# OpenType Hinting Freezer - Build Script

set -e

echo "🔧 Building OpenType Hinting Freezer..."

# Create virtual environment if it doesn't exist
if [ ! -d ".venv" ]; then
    echo "📦 Creating virtual environment..."
    python3 -m venv .venv
fi

# Activate virtual environment
source .venv/bin/activate

# Install build dependencies
echo "📦 Installing build dependencies..."
pip install --upgrade pip
pip install hatch build twine

# Install project dependencies
echo "📦 Installing project dependencies..."
pip install -e .[dev]

# Run linting and formatting
echo "🔍 Running code quality checks..."
hatch run format
hatch run lint
hatch run typecheck

# Run tests
echo "🧪 Running tests..."
hatch run test

# Build the package
echo "📦 Building package..."
hatch run build

echo "✅ Build completed successfully!"
</document_content>
</document>

<document index="19">
<source>scripts/release.sh</source>
<document_content>
#!/bin/bash
# this_file: scripts/release.sh
# OpenType Hinting Freezer - Release Script

set -e

# Check if a version tag is provided
if [ -z "$1" ]; then
    echo "❌ Error: Version tag is required"
    echo "Usage: $0 <version>"
    echo "Example: $0 v1.0.0"
    exit 1
fi

VERSION_TAG="$1"

# Validate version tag format (semantic versioning)
if ! [[ "$VERSION_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
    echo "❌ Error: Invalid version format. Expected format: v1.0.0 or v1.0.0-alpha"
    exit 1
fi

echo "🚀 Preparing release $VERSION_TAG..."

# Ensure we're on the main branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$CURRENT_BRANCH" != "main" ]; then
    echo "⚠️  Warning: Not on main branch. Currently on: $CURRENT_BRANCH"
    read -p "Continue anyway? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# Check if working directory is clean
if [ -n "$(git status --porcelain)" ]; then
    echo "❌ Error: Working directory is not clean. Please commit or stash changes."
    exit 1
fi

# Run full build and test
echo "🔧 Running full build and test..."
./scripts/build.sh

# Create and push the tag
echo "🏷️  Creating tag $VERSION_TAG..."
git tag -a "$VERSION_TAG" -m "Release $VERSION_TAG"
git push origin "$VERSION_TAG"

echo "✅ Release $VERSION_TAG created successfully!"
echo "📦 GitHub Actions will automatically build and publish the release."
</document_content>
</document>

<document index="20">
<source>scripts/test.sh</source>
<document_content>
#!/bin/bash
# this_file: scripts/test.sh
# OpenType Hinting Freezer - Test Script

set -e

echo "🧪 Running OpenType Hinting Freezer tests..."

# Create virtual environment if it doesn't exist
if [ ! -d ".venv" ]; then
    echo "📦 Creating virtual environment..."
    python3 -m venv .venv
fi

# Activate virtual environment
source .venv/bin/activate

# Install dependencies
echo "📦 Installing dependencies..."
pip install --upgrade pip
pip install hatch
pip install -e .[dev]

# Run different types of tests
echo "🔍 Running linting..."
hatch run lint

echo "🎨 Running formatting check..."
hatch run format --check

echo "🔬 Running type checking..."
hatch run typecheck

echo "🧪 Running unit tests..."
hatch run test

echo "📊 Running tests with coverage..."
hatch run test-cov

echo "✅ All tests passed!"
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/setup.py
# Language: python

import re
from pathlib import Path
from setuptools import find_packages, setup

def get_version((*args)):


# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/conftest.py
# Language: python

import pytest
from pathlib import Path
import tempfile
import shutil
import subprocess
import sys
from typing import Generator

def test_data_dir(()) -> Path:
    """Returns the test data directory."""

def sample_ttf_path(()) -> Path:
    """Returns the path to the sample TTF file."""

def output_dir(()) -> Generator[Path, None, None]:
    """Creates a temporary output directory for each test."""

def temp_dir(()) -> Generator[Path, None, None]:
    """Creates a temporary directory for each test."""

def cli_runner(()):
    """Returns a function to run CLI commands."""

def run_command((args: list[str])) -> subprocess.CompletedProcess:
    """Runs the CLI tool with the given arguments."""

def ensure_test_data(()):
    """Ensures test data files exist before running tests."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/generate_minimal_ttf.py
# Language: python

from fontTools.fontBuilder import FontBuilder
from fontTools.ttLib.tables._g_l_y_f import Glyph
from fontTools.pens.ttGlyphPen import TTGlyphPen
import os

def create_minimal_ttf((filepath="tests/data/minimal.ttf")):
    """ Creates a very minimal, valid TTF file with a single .notdef glyph...."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/test_cli_integration.py
# Language: python

import pytest
from pathlib import Path
import subprocess
import sys

def run_cli_command((args: list[str])) -> subprocess.CompletedProcess:
    """Runs the CLI tool with the given arguments."""

def ensure_sample_ttf_exists(()):
    """Ensure the sample TTF exists before tests run."""

def manage_output_dir(()):
    """Creates and cleans up the output directory for each test."""

def test_cli_basic_run_creates_output(()):
    """Test a basic CLI run creates an output file."""

def test_cli_help_message(()):
    """Test that the CLI shows a help message."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/test_error_handling.py
# Language: python

import pytest
from pathlib import Path
import tempfile
from opentype_hinting_freezer.hintingfreezer import freezehinting, read_from_path

def test_read_from_path_nonexistent_file(()):
    """Test that reading a non-existent file raises FileNotFoundError."""

def test_read_from_path_empty_file((temp_dir)):
    """Test reading an empty file."""

def test_freezehinting_invalid_font_file((temp_dir)):
    """Test freezehinting with an invalid font file."""

def test_freezehinting_negative_ppm((sample_ttf_path, temp_dir)):
    """Test freezehinting with negative PPM value."""

def test_freezehinting_zero_ppm((sample_ttf_path, temp_dir)):
    """Test freezehinting with zero PPM value."""

def test_freezehinting_very_large_ppm((sample_ttf_path, temp_dir)):
    """Test freezehinting with very large PPM value."""

def test_freezehinting_invalid_mode((sample_ttf_path, temp_dir)):
    """Test freezehinting with invalid mode."""

def test_freezehinting_invalid_subfont_index((sample_ttf_path, temp_dir)):
    """Test freezehinting with invalid subfont index."""

def test_freezehinting_readonly_output_directory((sample_ttf_path, temp_dir)):
    """Test freezehinting with read-only output directory."""

def test_freezehinting_output_to_existing_file((sample_ttf_path, temp_dir)):
    """Test freezehinting when output file already exists."""

def test_cli_missing_font_argument((cli_runner)):
    """Test CLI with missing font argument."""

def test_cli_nonexistent_font_file((cli_runner)):
    """Test CLI with non-existent font file."""

def test_cli_invalid_ppm_value((cli_runner, sample_ttf_path)):
    """Test CLI with invalid PPM value."""

def test_cli_invalid_mode_value((cli_runner, sample_ttf_path)):
    """Test CLI with invalid mode value."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/test_functionality.py
# Language: python

import pytest
from pathlib import Path
from opentype_hinting_freezer.hintingfreezer import freezehinting
from fontTools.ttLib import TTFont
import os
import os

def test_freezehinting_basic_functionality((sample_ttf_path, temp_dir)):
    """Test basic freezehinting functionality."""

def test_freezehinting_different_ppm_values((sample_ttf_path, temp_dir)):
    """Test freezehinting with different PPM values."""

def test_freezehinting_different_modes((sample_ttf_path, temp_dir)):
    """Test freezehinting with different rendering modes."""

def test_freezehinting_auto_output_name((sample_ttf_path, temp_dir)):
    """Test freezehinting with automatic output filename generation."""

def test_freezehinting_preserves_basic_font_structure((sample_ttf_path, temp_dir)):
    """Test that freezehinting preserves basic font structure."""

def test_freezehinting_with_variable_font_location((sample_ttf_path, temp_dir)):
    """Test freezehinting with variable font location (if applicable)."""

def test_cli_basic_functionality((cli_runner, sample_ttf_path, temp_dir)):
    """Test CLI basic functionality."""

def test_cli_auto_output_name((cli_runner, sample_ttf_path, temp_dir)):
    """Test CLI with automatic output filename generation."""

def test_cli_help_shows_all_options((cli_runner)):
    """Test that CLI help shows all expected options."""

def test_freezehinting_consistent_output((sample_ttf_path, temp_dir)):
    """Test that freezehinting produces consistent output for same parameters."""

def test_freezehinting_different_outputs_for_different_params((sample_ttf_path, temp_dir)):
    """Test that different parameters produce different outputs."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/test_hintingfreezer_unit.py
# Language: python

import pytest
from pathlib import Path
from opentype_hinting_freezer.hintingfreezer import read_from_path

def test_read_from_path_success(()):
    """Test successfully reading data from a file."""

def test_read_from_path_file_not_found(()):
    """Test FileNotFoundError when reading a non-existent file."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/fonttools-opentype-hinting-freezer/tests/test_performance.py
# Language: python

import pytest
import time
from pathlib import Path
from opentype_hinting_freezer.hintingfreezer import freezehinting
import psutil
import os

def test_freezehinting_performance_benchmark((sample_ttf_path, temp_dir)):
    """Test freezehinting performance benchmark."""

def test_freezehinting_memory_usage((sample_ttf_path, temp_dir)):
    """Test memory usage during freezehinting."""

def test_multiple_ppm_values_performance((sample_ttf_path, temp_dir)):
    """Test performance with multiple PPM values."""

def test_all_modes_performance((sample_ttf_path, temp_dir)):
    """Test performance with all rendering modes."""

def test_cli_performance_benchmark((cli_runner, sample_ttf_path, temp_dir)):
    """Test CLI performance benchmark."""


</documents>